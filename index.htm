<!DOCTYPE html>
<html>
<head>
    <title>Binary Pattern Generator v0.95</title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>

    <!-- 1BIT SHADER FUNCTIONS -->
    <script src="js/functions.js"> </script>

    <div class="sidebar">
        <div class="title">Pattern Controls</div>
        <div class="control-group">
            <label for="param1">param1 (-99 - 99):</label>
            <input type="range" id="param1" min="-99" max="99" value="11">
        </div>
        <div class="control-group">
            <label for="param2">param2 (-99 - 99):</label>
            <input type="range" id="param2" min="-99" max="99" value="15">
        </div>
        <div class="control-group">
            <label for="param3">param3 (2-99):</label>
            <input type="range" id="param3" min="2" max="99" value="3">
        </div>
        <div class="control-group">
            <label for="modfun">function modifier (1-3):</label>
            <input type="range" id="modfun" min="1" max="3" value="2">
        </div>
        <div class="control-group">
            <label for="function-code">Pattern Function:</label>
            <textarea id="function-code" rows="13" style="width: 94%; ">function f(x, y, param1, param2, param3) {
    if (x === 0) return 0;
        
    return ((~((y * param1) % (x + y))) ^ (((1 ^ y) ^ (-y)) - (~(y / param2)))) % param3;
}
            </textarea>
        </div>

        <div class="button-group" style="width: 102%; ">
            <button id="invert-btn" class="glass-button"><i class="fa-solid fa-square"></i> &nbsp;Invert</button>
            <button id="color-btn" class="glass-button"><i class="fa-solid fa-droplet"></i> &nbsp;Colors</button>
            <button id="integer-btn" class="glass-button"><i class="fa-solid fa-wave-square"></i> &nbsp;Int</button>
        </div>
        <br />
        <div class="button-group" style="width: 100%; ">
            <button id="rndfn-btn" class="glass-button"><b><i class="fa-solid fa-dice"></i> Function</b></button>
            <button id="rndfn-val" class="glass-button"><b><i class="fa-solid fa-shuffle"></i> Values</b></button>
            <button id="update-btn" class="glass-button"><i class="fa-solid fa-rotate-right"></i></button>
        </div>

    </div>

    <div class="main-content">
        <canvas id="canvas" width="768" height="768"></canvas>
    </div>

    <div class="sidebar">
        <a href="https://github.com/masayume/1bit-pattern-gen/"></a><h2>Binary Pattern Generator</h2></a>
        <p id="par1">
            by <a href="https://masayume.it">masayume</a>, ver. <b>0.95</b>, functions: 
        </p>
        <script>
            par1.textContent += (functions.length + 1);
        </script>
        <p>
            From  <a href="https://freeradical.zone/@bitartbot">bitartbot</a>, a bot which produces procedural art 
            by plotting an integer function taking the current coordinates and producing an integer result. 
            The function is procedurally created using random numbers and appears in the status text.
        </p>
        <p>
            Coordinates are coloured either by where the value appears within the range of results 
            (the "gradient" scheme) or simply by whether it is the most common result (white) or not (black) 
            (the "onebit" scheme.)
        </p>
        <p>
            The code does not resort to evaluating a string.
        </p>
        </p>
        <div class="button-group">
            <button id="save-btn" class="glass-button"><b><i class="fa-solid fa-floppy-disk"></i> Image</b></button>
            <button id="save4x-btn" class="glass-button"><b><i class="fa-solid fa-floppy-disk"></i> 4X</b></button>
        </div>

    </div>    

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const scale = 3;
        const baseSize = 256;
        let invert = 0;
        
        const bufferCanvas = document.createElement('canvas');
        bufferCanvas.width = baseSize;
        bufferCanvas.height = baseSize;
        const bufferCtx = bufferCanvas.getContext('2d');
        const imageData = bufferCtx.createImageData(baseSize, baseSize);

        const param1Input = document.getElementById('param1');
        const param2Input = document.getElementById('param2');
        const param3Input = document.getElementById('param3');
        const modfunInput = document.getElementById('modfun');
        const invertInput = document.getElementById('invert-btn');
        const functionCode = document.getElementById('function-code');
        const updateBtn = document.getElementById('update-btn');
        const saveBtn = document.getElementById('save-btn');
        const save4xBtn = document.getElementById('save4x-btn');
        const rnfFnBtn = document.getElementById('rndfn-btn');
        const rnfVlBtn = document.getElementById('rndfn-val');

        let updateTimeout = null;

        function resetParam3Randomly(param) {
            const param3Input = document.getElementById(param);
            const minValue = parseInt(param3Input.min);
            const maxValue = parseInt(param3Input.max);
            const randomValue = Math.floor(Math.random() * (maxValue - minValue + 1)) + minValue;
            param3Input.value = randomValue;
        }

        function invertVal() {

            if (parseInt(invertVal.value) == 1) {
                invert = 0
            } else {
                invert = 1
            } 
        }

        function updatePattern() {
            if (updateTimeout) {
                clearTimeout(updateTimeout);
            }

            updateTimeout = setTimeout(() => {
                const param1 = parseInt(param1Input.value);
                const param2 = parseInt(param2Input.value);
                const param3 = parseInt(param3Input.value);
                const modfun = parseInt(modfunInput.value);


                try {
                    eval(functionCode.value);
                    
                    const data = imageData.data;
                    for (let y = 0; y < baseSize; y++) {
                        for (let x = 0; x < baseSize; x++) {

                            let value = 0;
                            // EVAL FUNCTION
                            if (modfun != 1) {
                                value = f(x, y, param1, param2, param3) % modfun;
                            } else {
                                value = f(x, y, param1, param2, param3);                                
                            }

                            if (invert) value = 1 - value;
                            const color = value * 255;
                            
                            const idx = (y * baseSize + x) * 4;
                            data[idx] = data[idx + 1] = data[idx + 2] = color;
                            data[idx + 3] = 255;
                        }
                    }
                    
                    bufferCtx.putImageData(imageData, 0, 0);
                    
                    ctx.imageSmoothingEnabled = false;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(bufferCanvas, 0, 0, canvas.width, canvas.height);
                    
                } catch (error) {
                    alert('Error in function code: ' + error.message);
                }
            }, 50);
        }

        function flipCanvas(originalCanvas) {
            // Create a new canvas with the same dimensions
            const flippedCanvas = document.createElement('canvas');
            const width = originalCanvas.width;
            const height = originalCanvas.height;
            flippedCanvas.width = width;
            flippedCanvas.height = height;
            
            // Get the context for both canvases
            const ctx = flippedCanvas.getContext('2d');
            
            // Save the current context state
            ctx.save();
            
            // Translate and scale to flip both horizontally and vertically
            ctx.translate(width, height);
            ctx.scale(-1, -1);
            
            // Draw the original canvas onto the new one
            ctx.drawImage(originalCanvas, 0, 0);
            
            // Restore the context state
            ctx.restore();
            
            return flippedCanvas;
        }

        function saveImage() {
            const link = document.createElement('a');
            link.download = 'pattern.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function saveImage4X() {

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width * 2;
            tempCanvas.height = canvas.height * 2;

            // Draw original (top-left)
            tempCtx.drawImage(canvas, 0, 0);

            // Draw horizontally flipped (top-right)
            tempCtx.save();
            tempCtx.translate(canvas.width * 2, 0);
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(canvas, 0, 0);
            tempCtx.restore();

            // Draw vertically flipped (bottom-left)
            tempCtx.save();
            tempCtx.translate(0, canvas.height * 2);
            tempCtx.scale(1, -1);
            tempCtx.drawImage(canvas, 0, 0);
            tempCtx.restore();

            // Draw both flipped (bottom-right)
            tempCtx.save();
            tempCtx.translate(canvas.width * 2, canvas.height * 2);
            tempCtx.scale(-1, -1);
            tempCtx.drawImage(canvas, 0, 0);
            tempCtx.restore();

            // Save the combined image
            const link = document.createElement('a');
            link.download = 'pattern.png';
            link.href = tempCanvas.toDataURL('image/png');
            link.click();

        }

        const functionPrefix = `  function f(x, y, param1, param2, param3) {
if (x === 0) return 0;
        
return `;

        const functionPostfix = `

}
        `;
        function selectRandomFunction() {
            const randomIndex = Math.floor(Math.random() * functions.length);
            const textarea = document.getElementById('function-code');

            textarea.value = functionPrefix + functions[randomIndex] + functionPostfix;

//          EXPERIMENTAL
//          textarea.value = functionPrefix + generateRandomExpression('param1', 'param2', 'param3') + functionPostfix;

            randomizeValues();
        }

        function randomizeValues() {
            resetParam3Randomly('param1');
            resetParam3Randomly('param2');
            resetParam3Randomly('param3');

            updatePattern();
        }

        /**
         * Generates an array of colors representing a quantized gradient between two colors
         * @param {string} startColor - Starting color in hex format (e.g. '#ff0000')
         * @param {string} endColor - Ending color in hex format (e.g. '#0000ff')
         * @param {number} steps - Number of colors to generate in the gradient
         * @returns {string[]} Array of hex color strings
         */
        function generateQuantizedGradient(startColor, endColor, steps) {
          // Convert hex to RGB
          const hexToRgb = (hex) => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
              r: parseInt(result[1], 16),
              g: parseInt(result[2], 16),
              b: parseInt(result[3], 16)
            } : null;
          };

          // Convert RGB to hex
          const rgbToHex = (r, g, b) => {
            const componentToHex = (c) => {
              const hex = Math.round(c).toString(16);
              return hex.length === 1 ? '0' + hex : hex;
            };
            return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
          };

          const start = hexToRgb(startColor);
          const end = hexToRgb(endColor);

          if (!start || !end) {
            throw new Error('Invalid hex color format');
          }

          const gradient = [];

          // Calculate step size for each color component
          const stepR = (end.r - start.r) / (steps - 1);
          const stepG = (end.g - start.g) / (steps - 1);
          const stepB = (end.b - start.b) / (steps - 1);

          // Generate colors
          for (let i = 0; i < steps; i++) {
            const r = start.r + (stepR * i);
            const g = start.g + (stepG * i);
            const b = start.b + (stepB * i);
            gradient.push(rgbToHex(r, g, b));
          }

          return gradient;
        }

        function generateRandomExpression(params) {
          const operators = ['+', '-', '*', '/', '%', '&', '|', '^', '~'];
          const operands = ['x', 'y'];

          function getRandomElement(array) {
            return array[Math.floor(Math.random() * array.length)];
          }

          function generateSubExpression() {
            const operand1 = getRandomElement(operands);
            const operator = getRandomElement(operators);
            const operand2 = Math.random() < 0.5 ? getRandomElement(operands) : 
                              Math.random() < 0.5 ? getRandomElement(params) : 
                              Math.random() < 0.5 ? `(${generateSubExpression()})` : 
                              Math.floor(Math.random() * 10); 

            return `(${operand1} ${operator} ${operand2})`;
          }

          let expression = generateSubExpression();

          // Add more layers of complexity
          for (let i = 0; i < Math.floor(Math.random() * 3); i++) {
            const newOperator = getRandomElement(operators);
            const newOperand = Math.random() < 0.5 ? generateSubExpression() : 
                              Math.random() < 0.5 ? getRandomElement(params) : 
                              Math.random() < 0.5 ? `(${generateSubExpression()})` : 
                              Math.floor(Math.random() * 10); 
            expression = `(${expression} ${newOperator} ${newOperand})`;
          }

          return expression + ` % ${getRandomElement(params)}`; 
        }

        /*
        // Example usage:
        const blueToRed = generateQuantizedGradient('#0000ff', '#ff0000', 5);
        console.log(blueToRed);
        // Output: ['#0000ff', '#3f00bf', '#7f007f', '#bf003f', '#ff0000']

        const greenToYellow = generateQuantizedGradient('#00ff00', '#ffff00', 3);
        console.log(greenToYellow);
        // Output: ['#00ff00', '#7fff00', '#ffff00']
        */

        param1Input.addEventListener('input', updatePattern);
        param2Input.addEventListener('input', updatePattern);
        param3Input.addEventListener('input', updatePattern);
        modfunInput.addEventListener('input', updatePattern);
        invertInput.addEventListener('click', invertVal);
        updateBtn.addEventListener('click', updatePattern);
        saveBtn.addEventListener('click', saveImage);
        save4xBtn.addEventListener('click', saveImage4X);
        rnfFnBtn.addEventListener('click', selectRandomFunction);
        rnfVlBtn.addEventListener('click', randomizeValues);

        updatePattern();
    </script>
</body>
</html>